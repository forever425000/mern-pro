You worry for me in the twilight
You shed tears for me until midnight
Your amazing grace wears out for me
You grow much older carrying for me
Not just for yourself but just for little one
You lead your whole life like candlelight
You kept the keen eyes on our every pace
Only you make my cradle bright
Your love has kept me warm all this time
Oh my dear mother I love so..

server.js
process.env.NODE_ENV = process.env.NODE_ENV  development;

var express = require(.configexpress),
    mongoose = require(.configmongoose),
    passport = require(.configpassport),
    config = require(.configconfig),
    http = require(http);

mongoose().then(() = {
    var app = express();
    passport();
    var server = http.createServer(app);
    server.listen(config.port, () = {
        console.log(`Server is running at httplocalhost${config.port}`)
    });
});

package.json
{
  name standard-mern-skeleton-backend,
  version 1.0.0,
  description This is a standard MERN Stack project.,
  main server.js,
  scripts {
    test echo Error no test specified && exit 1,
    start nodemon server.js
  },
  keywords [
    MERN,
    FullstackJS,
    Standard Web Project
  ],
  author blackhole,
  license ISC,
  dependencies {
    bcryptjs ^2.4.3,
    body-parser ^1.20.2,
    cors ^2.8.5,
    express ^4.18.2,
    express-validator ^7.0.1,
    jsonwebtoken ^9.0.0,
    method-override ^3.0.0,
    mongoose ^7.2.0,
    morgan ^1.10.0,
    multer ^1.4.5-lts.1,
    passport ^0.4.0,
    passport-jwt ^4.0.0,
    passport-local ^1.0.0
  },
  devDependencies {
    @typesexpress ^4.17.17,
    @typesexpress-validator ^3.0.0,
    @typesmongoose ^5.11.97,
    dotenv ^16.1.3,
    nodemon ^2.0.22,
    ts-node ^10.9.1,
    tslint ^6.1.3,
    typescript ^5.0.4
  }
}
.env/development.js
module.exports = {
    port 3500,
    db mongodb192.168.144.14327018standard-mern,
    secret MYSECRETKEY
}
middlewares/requireAdmin.js
module.exports = (req, res, next) = {
    if (!req.user) {
        return res.status(401).send(Before you must login.);
    } else if (req.user.role !== 1) {
        console.error(req.user.username, req.ip, Access to admin role);
        return res.status(401).send(Your role is not admin.);
    } else {
        next();
    }
}
//strategies/jwt.js
var passport = require('passport'),
    JwtStrategy = require('passport-jwt').Strategy,
    ExtractJwt = require('passport-jwt').ExtractJwt,
    User = require('mongoose').model('User'),
    config = require('../config');

const jwtOptions = {
    jwtFromRequest ExtractJwt.fromHeader('authorization'),
    secretOrKey config.secret
};

module.exports = function () {
    passport.use(new JwtStrategy(jwtOptions, function (payload, done) {
        User.findById(payload._id).then(user = {
            if (user) {
                done(null, user);
            } else {
                done(null, false);
            }
        }).catch(err = {
            console.log(err);
            return done(err, false)
        });
    }));
} 
strategieslocal.js
const jwt = require('.jwt');

var passport = require('passport'),
    LocalStrategy = require('passport-local').Strategy,
    User = require('mongoose').model('User');

module.exports = function() {
    passport.use(new LocalStrategy(function(username, password, done) {
        User.findOne({
            username username
        }).then(async user = {
            if (!user) {
                return done('User cannot find.', false);
            }

            if (user.allow === 0) {
                return done('Let you get admin accepting.', false);
            }

            if (user.allow === -1) {
                return done('Your username was blocked.', false);
            }

            if (!user.authenticate(password)) {
                return done('Password is wrong!', false);
            }
            await User.updateOne({ username username }, { logins user.logins + 1, lastLogin Date.now() }); 
            return done(null, user);
        }).catch(err = done(err));
    }));
};
.utilscatchAsync.js
const handleError = require(.handleError);

module.exports = fn = {
    return (req, res, next) = {
        fn(req, res, next).catch(err = handleError(err, res));
    }
}
getToken.js
const handleError = require(.handleError);

module.exports = fn = {
    return (req, res, next) = {
        fn(req, res, next).catch(err = handleError(err, res));
    }
}
handleError.js
module.exports = (err, res) = {
    console.log(err);
    return res.status(500).send(Error corrupted.);
}
config.js
module.exports = require(.env + process.env.NODE_ENV + .js);
express.js
var express = require(express),
    bodyParser = require(body-parser),
    morgan = require(morgan),
    passport = require(passport),
    cors = require(cors),
    methodOverride = require(method-override),
     path = require(path),
    routers = require(.routers);

module.exports = () = {

    var app = express();    

    app.use(bodyParser.json());
    app.use(bodyParser.urlencoded({
        extended true
    }));
    app.use(cors());
    app.use(morgan(dev));
    app.use(methodOverride());

    app.use(passport.initialize());
    app.use(passport.session());

    routers.map(router = {
        app.use(`api${router}`, require(`..routers${router}.router`));
    });

     app.use(express.static(path.resolve(__dirname, ..views)));
     app.get(, (req, res) = res.sendFile(path.resolve(__dirname, ..views, index.html)));

    return app;
}
models.js
module.exports = [
    user,
];
mongoose.js
var mongoose = require(mongoose),
    config = require(.config),
    models = require(.models);

module.exports = () = new Promise((resolve) = {
    mongoose.connect(config.db, {
        useNewUrlParser true,
        useUnifiedTopology true
    });
                            
    mongoose.connection.on(connected, () = {
        console.log(MongoDB connected.);
        models.map(model = require(`..models${model}.model`));
        resolve();
    });

    mongoose.connection.on(disconnected, () = {
        console.log(MongoDB connected.);
    });

    mongoose.connection.on('error', function (err) {
        console.log(`Mongoose connection error ${err}`);
    });
});
passport.js
var passport = require('passport'),
    mongoose = require('mongoose');

module.exports = function() {
    var User = mongoose.model('User');

    passport.serializeUser(function(user, done) {
        done(null, user.id);
    });
    passport.deserializeUser(function(id, done) {
        User.findOne({
            _id id
        }).select('-password -salt').then(user = {
            done(null, user);
        }).catch(err = done(err));
    });
    

    require('.strategieslocal.js')();
    require('.strategiesjwt.js')();
};
routers.js'
module.exports = [
    user,
]
controllersuser.controller.js
const getToken = require(..configutilsgetToken);
const handleError = require(..configutilshandleError);
const catchAsync = require(..configutilscatchAsync);

var mongoose = require(mongoose),
    User = mongoose.model(User),
    jwt = require(jsonwebtoken),
    config = require(..configconfig);

exports.register = (req, res) = {
    let { username, password, name, gender, birthday, address, phone } = req.body;
    User.create({
        username, password, name, gender, birthday, address, phone,
    }).then(user = {
        res.status(200).send(user);
    }).catch(err = handleError(err, res));
}

exports.login = (req, res) = {
    res.status(200).send({
        token getToken(req.user),
        user req.user
    });
}

exports.loginWithToken = (req, res) = {
    let { token } = req.body;
    jwt.verify(token, config.secret, (err, payload) = {
        if (err) return res.status(401).send(Unauthorized.);
        else {
            User.findById(payload._id).select('-password -salt').then(user = {
                return res.status(200).send({
                    token getToken(user),
                    user
                });
            }).catch(err = handleError(err, res));
        }
    });
}

exports.detail = (req, res) = {
    User.findById(req.params.id)
        .select(-password -salt)
        .then(user = {
            if (!user) return res.status(404).send(Cannot find user.);
            else return res.status(200).send(user);
        }).catch(err = handleError(err, res));
}

exports.list = (req, res) = {
    User.find({})
        .select(-password -salt)
        .then(data = {
            res.status(200).send(data);
        }).catch(err = handleError(err, res));
}

exports.update = catchAsync(async (req, res) = {
    let id = req.params.id;
    await User.findByIdAndUpdate(id, req.body);
    res.status(200).send(Successfully updated.);
});

exports.delete = catchAsync(async (req, res) = {
    let id = req.params.id;
    await User.findByIdAndDelete(id);
    res.status(200).send(Successfully deleted.);
});

exports.formatPassword = catchAsync(async (req, res) = {
    let id = req.params.id;
    let user = await User.findById(id);
    user.password = 1234567890;
    await user.save();
    res.status(200).send(Successfully updated.);
});
modelsuser.router.js
var mongoose = require('mongoose'),
    Schema = mongoose.Schema,
    crypto = require('crypto');

var UserSchema = new Schema({
    username {
        type String,
        required [true, Insert your username.],
        unique [true, Username have to be unique string.],
        lowercase true
    },
    password {
        type String,
        validate [
            function (password) {
                return password && password.length = 6;
            }, 'Password must provide over 6 characters.'
        ]
    },
    name {
        type String,
        required [true, Insert name.]
    },
    gender {
        type String,
        default male  
    },
    address {
        type String,
        default 
    },
    phone {
        type String,
        default 191-000-0000
    },
    lastLogin {  lastest login time
        type Date,
        default Date.now()
    },
    logins {  login number
        type Number,
        default 0
    },
     roles {  
         type [String],
          default [user]  'user' is common user, admin is administrator, signer is publish tester
     },
    role {
        type Number,
        default 0
    },
    allow {  using allow
        type Number,
        default 1  0 is waiting, -1 is block, 1 is accept
    },
    salt {
        type String
    },
}, {
    timestamps true
});

 To hash password before save into database
UserSchema.pre('save', function (next) {
    if (this.isModified('password')) {
        this.salt = new Buffer.alloc(16, crypto.randomBytes(16).toString('base64'), 'base64');
        this.password = this.hashPassword(this.password);
    }
    next();
});

 Return hased password
UserSchema.methods.hashPassword = function (password) {
    return crypto.pbkdf2Sync(password, this.salt, 10000,
        64, 'sha512').toString('base64');
};

 Compared hased password from user with database's password so if exist, then res is true, not false
UserSchema.methods.authenticate = function (password) {
    return this.password === this.hashPassword(password);
};

UserSchema.set('toJSON', {
    getters true,
    virtuals true
});

 Register maked Schema as User moder into Database
 Third parameter is collection name that User model register into database as user 
 If you don't give third parameter, register into Database as users 
mongoose.model('User', UserSchema, user);
routersuser.router.js
var passport = require(passport),
    requireSignin = passport.authenticate(local, { session false }),
    requireAuth = passport.authenticate(jwt, { session false }),
    router = require(express).Router(),
    userCtr = require(..controllersuser.controller),
    requireAdmin = require(..configmiddlewaresrequireAdmin);

router.post(register, userCtr.register);
router.post(login, requireSignin, userCtr.login);
router.post(login-with-token, userCtr.loginWithToken);
router.get(detailid, requireAuth, userCtr.detail);
router.get(list, requireAuth, userCtr.list);
router.put(id, requireAuth, requireAdmin, userCtr.update);
router.delete(id, requireAuth, requireAdmin, userCtr.delete);
router.post(format-passwordid, requireAuth, requireAdmin, userCtr.formatPassword);

module.exports = router;

